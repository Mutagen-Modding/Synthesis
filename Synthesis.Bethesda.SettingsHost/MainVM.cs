using Noggog.WPF;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Mutagen.Bethesda.Synthesis.WPF;
using DynamicData;
using Noggog;
using ReactiveUI;
using System.Reactive.Linq;
using Mutagen.Bethesda;
using System.Reactive;
using System.Reactive.Disposables;
using System.Threading;
using Synthesis.Bethesda.DTO;

namespace Synthesis.Bethesda.SettingsHost
{
    public class MainVM : ViewModel
    {
        private readonly ObservableAsPropertyHelper<AutogeneratedSettingsVM?> _AutogeneratedSettings;
        public AutogeneratedSettingsVM? AutogeneratedSettings => _AutogeneratedSettings.Value;

        public string WindowName { get; }

        public MainVM(HostSettings host)
        {
            WindowName = $"{host.PatcherName} Settings";
            WarmupAll.Init();

            var loadOrderResult = Observable.Return(Unit.Default)
                .ObserveOn(RxApp.TaskpoolScheduler)
                .Select(_ =>
                {
                    System.Console.Error.WriteLine($"Getting live load order for {host.GameRelease} -> {host.DataFolderPath}");
                    var liveLo = Mutagen.Bethesda.LoadOrder.GetLiveLoadOrder(host.GameRelease, host.DataFolderPath, out IObservable<ErrorResponse> errors)
                        .Transform(listing => new LoadOrderEntryVM(listing, host.DataFolderPath))
                        .DisposeMany();
                    return (Results: liveLo, State: errors);
                })
                .StartWith((Results: Observable.Empty<IChangeSet<LoadOrderEntryVM>>(), State: Observable.Return(ErrorResponse.Fail("Load order uninitialized"))))
                .Replay(1)
                .RefCount();

            loadOrderResult.Select(x => x.State)
                .Switch()
                .Subscribe(e =>
                {
                    Console.Error.WriteLine(e);
                })
                .DisposeWith(this);

            var loadOrder = loadOrderResult
                .Select(x => x.Results)
                .Switch()
                .AsObservableList();

            var linkCache = loadOrder.Connect()
                    .QueryWhenChanged()
                    .Select(q => q.Where(x => x.Listing.Enabled).Select(x => x.Listing.ModKey).ToArray())
                    .StartWithEmpty()
                .Throttle(TimeSpan.FromMilliseconds(100), RxApp.TaskpoolScheduler)
                .Select(x =>
                {
                    return Observable.Create<ILinkCache>(obs =>
                    {
                        var loadOrder = Mutagen.Bethesda.LoadOrder.Import(
                            host.DataFolderPath,
                            x,
                            factory: (modPath) => ModInstantiator.Importer(modPath, host.GameRelease));
                        obs.OnNext(loadOrder.ToUntypedImmutableLinkCache(LinkCachePreferences.OnlyIdentifiers()));
                        obs.OnCompleted();
                        return Disposable.Empty;
                    });
                })
                .Switch()
                .Replay(1)
                .RefCount();

            _AutogeneratedSettings = Observable.Return(Unit.Default)
                .ObserveOn(RxApp.TaskpoolScheduler)
                .SelectTask(async _ =>
                {
                    try
                    {
                        var config = await Synthesis.Bethesda.Execution.CLI.Commands.GetSettingsStyle(
                            host.PatcherPath,
                            directExe: false,
                            cancel: CancellationToken.None,
                            build: false,
                            log: (s) => Console.WriteLine(s));
                        return new AutogeneratedSettingsVM(
                            config,
                            projPath: host.PatcherPath,
                            displayName: host.PatcherName,
                            loadOrder: loadOrder.Connect(),
                            linkCache: linkCache,
                            log: (s) => Console.WriteLine(s));
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine(ex);
                        return default(AutogeneratedSettingsVM?);
                    }
                })
                .ToGuiProperty(this, nameof(AutogeneratedSettings), default);
        }

        public void Save()
        {
            if (AutogeneratedSettings == null) return;
            AutogeneratedSettings.Bundle?.Settings?.ForEach(s => s.Persist((l) => Console.WriteLine(l)));
        }
    }
}
