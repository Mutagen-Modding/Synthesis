{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"What does Synthesis do?","text":"<p>Synthesis allows modders to develop mods via code, rather than by hand.  These are often referred to as \"patchers\".</p> <p>As a user creating a modded load order, Synthesis lets you add as many of these patcher mods as you like, and bundle them together into one single mod file: <code>Synthesis.esp</code>.  You should rerun the Synthesis pipeline any time you add/remove mods so the patchers can change and adapt to the new content.</p> <p></p>"},{"location":"#for-users","title":"For Users:","text":"<p>Easily add patchers and run patcher pipelines on your game.  </p> <p></p> <p> Installation</p> <p> Typical Usage</p>"},{"location":"#for-developers","title":"For Developers:","text":"<p>Utilize development tools provided by Synthesis to help you create Mutagen patchers from scratch</p> <pre><code>// Loop every NPC in the game\nforeach (var npc in state.LoadOrder.PriorityOrder.Npc().WinningOverrides())\n{\n    // Add the record as an override to the new patch\n    var overrideNpc = state.PatchMod.Npcs.GetOrAddAsOverride(npc);\n\n    // Add 10% to their height\n    overrideNpc.Height *= 1.1f;\n}\n</code></pre> <p> Create a Patcher</p>"},{"location":"Blacklisting/","title":"Blacklisting Mods","text":""},{"location":"Blacklisting/#by-group","title":"By Group","text":"<p>Synthesis Groups can blacklist mods.  To do so, click on the Group of interest, and a UI should show that lets you pick the mods to not include during patching of that group.</p> <p></p>"},{"location":"Blacklisting/#by-patcher","title":"By Patcher","text":""},{"location":"Blacklisting/#patcher-settings","title":"Patcher Settings","text":"<p>Individual patcher developers can decide to offer patcher settings that expose a mod blacklist as they see fit.</p> <p>If a patcher does not offer the setting, it is something they can decide to add.  Perhaps add a request on the patcher's Github page.</p>"},{"location":"Blacklisting/#synthesis-provided-per-patcher-blacklist","title":"Synthesis Provided Per-Patcher Blacklist","text":"<p>Synthesis itself does not provide functionality to blacklist a mod for a specific patcher.  There's an issue for it in the works.</p> <p>In the meantime, if a patcher does not offer a mod blacklist within its own settings, your best option is to put the patcher by itself in a Group and use the blacklist it offers, as described above.</p>"},{"location":"Compaction/","title":"Compaction","text":"<p>Mods in newer Bethesda games can have specific flags marked to enforce specific compaction of their records so the game can load more of them.   The game engine can load more of these mods with smaller compaction, but the tradeoff is those mods can define less overall records.</p> <p>These are often referred to as <code>Small</code>/<code>Medium</code>/<code>Full</code> master mods.  Skyrim often refers to <code>Small</code> as <code>Light</code>.   By default, Synthesis exports as <code>Full</code>, for simplicity, and to allow as many records as possible to be defined within a patch mod.</p> <p>If you would like to adjust the compaction style of your patches, the profile settings have a few settings.</p> <p></p> <p>Here, you can select <code>Small</code>/<code>Medium</code>/<code>Full</code> as applicable to your target game.</p> <p>Additionally, <code>Fallback on Overflow</code> can be selected to automatically use \"larger\" compaction settings if the smaller one selected overflows and contains too many records.</p> <p>Starfield</p> <p>Starfield is less flexible with compaction styles changing on the fly, so \"Fallback on Overflow\" is not recommended, and changing compaction styles in general should be done rarely.</p>"},{"location":"DataFolder/","title":"Data Folder","text":"<p>Synthesis by default looks at the typical game registry areas to automatically locate the installation folder for the targeted game.   However, if you have multiple installations, you may want to override and have Synthesis target a different location. </p> <p>This can be done by editing the profile settings:</p> <p></p> <p>It should then look to the new location when reading/writing mods.   You can leave it blank to go back to automatic location logic.</p>"},{"location":"External-Program-Patcher/","title":"External Program Patcher","text":"<p>This type latches on and executes any executable program (exe).  It will pass along the Synthesis command line arguments to inform the program of what it should be patching, and where to put its results.  </p> <p></p>"},{"location":"External-Program-Patcher/#goals-and-reasons-to-choose","title":"Goals and Reasons to Choose","text":"<p>This patcher type is meant for non-Mutagen based patcher programs that want to participate in a Synthesis patch pipeline.  As long as the program can take in the command line arguments, and produce a patch file in the desired location, it can be a patcher within Synthesis.</p> <p>Not for Mutagen-Based Patchers</p> <p>This is not typically used with Mutagen-based patchers, as Git Repository or Local Solution are better options.</p>"},{"location":"External-Program-Patcher/#required-input","title":"Required Input","text":"<p>The only required input is a path to the executable file to run.</p>"},{"location":"FAQ-and-Troubleshooting/","title":"FAQ and Troubleshooting","text":""},{"location":"FAQ-and-Troubleshooting/#check-out-the-discussions-tab","title":"Check out the Discussions tab","text":"<p>Rather than writing wiki articles about common questions and problems, the Discussions area is the place to look and ask!</p> <p>It is a Stack Overflow style question and answer area that hopefully will serve the job better than static wiki pages.</p>"},{"location":"Git-Repository-Patcher/","title":"Git Repository Patcher","text":"<p>This type latches on to a patcher accessible via a Git Repository address (usually hosted on Github.com).  It will clone the code and build the exe to run locally on your machine.  It only supports Mutagen-based projects.</p> <p></p> <p>Recommended</p> <p>This is the recommended patcher type for typical users</p>"},{"location":"Git-Repository-Patcher/#reasons-to-choose","title":"Reasons to Choose","text":"<p>Because it builds code on your machine, it has a few upsides:</p> <ul> <li>Can automatically update to the latest version of a patcher's code</li> <li>Can artificially update a patcher to the latest version of Mutagen/Synthesis to grab bugfixes and optimizations</li> <li>Does not require a patcher author to explicitly create and publish an exe to be runnable</li> </ul>"},{"location":"Git-Repository-Patcher/#installation","title":"Installation","text":""},{"location":"Git-Repository-Patcher/#manual-input","title":"Manual Input","text":"<p>The <code>Input</code> pane allows you to create a Git Patcher by explicitly providing the repository details</p> <ul> <li>Address of the git repository</li> <li>Project within the repository to use (a repository could have multiple patchers, for example)</li> </ul>"},{"location":"Git-Repository-Patcher/#patcher-browser","title":"Patcher Browser","text":"<p>Alternatively, you can make use of the \"Browse\" feature, which lists a whole load of patchers that were automatically located on Github.</p> <p></p> <p>To get to the Patcher browser, click and add a new Git Repository Patcher at the top left, and then go to the Browse tab.</p>"},{"location":"Git-Repository-Patcher/#versioning","title":"Versioning","text":"<p>Git Repository Patchers have the unique capability of being able to control what code you want to use for a patcher.</p> <p>This is an important topic, and so has received its own section in the Overview documentation</p> <p> Versioning</p> <p></p>"},{"location":"Installation/","title":"Installation","text":""},{"location":"Installation/#install-latest-net-sdk","title":"Install Latest .NET SDK","text":"<p>You can get the typical SDK installation from Microsoft's official page</p> <p> Download SDK</p> <p>Avoid install/uninstalling SDKs repeatedly</p> <p>If after installing the .NET SDK as instructed above it doesn't work, try following this FAQ first</p> <p>Restart</p> <p>It's usually a good idea to restart your computer after installing DotNet SDK to help things settle in.</p>"},{"location":"Installation/#runtime-is-not-the-sdk","title":"Runtime Is Not The SDK","text":"<ul> <li><code>.NET Runtime</code> -&gt; Enables you to you run existing .NET programs (such as the Synthesis UI)</li> <li><code>.NET SDK</code> -&gt; Enables you to compile code</li> </ul> <p>Some users get confused and just install the <code>.NET Runtime</code>.  The <code>Runtime</code> is required, but Microsoft itself will prompt you to install this when trying to start the Synthesis UI, if it is missing.</p> <p>Be sure to install the <code>SDK</code>; The <code>Runtime</code> alone is not enough.  </p>"},{"location":"Installation/#download-synthesis-ui","title":"Download Synthesis UI","text":"<p>To download Synthesis itself, go is the GitHub release section</p> <p> Download Synthesis UI</p> <p>On the latest release, download just the Synthesis.zip file.  The other files are not needed.</p> <p>Unzip the archive somewhere you like</p> <p>Unzip All Files</p> <p>Make sure you bring along ALL the files within the zip, not just <code>Synthesis.exe</code></p> <p>Dedicated Folder</p> <p>The app will create a few files nearby itself, so it is good to put it within its own folder.</p>"},{"location":"Installation/#run-synthesis","title":"Run Synthesis","text":"<p>You're ready to run Synthesis!</p> <p></p>"},{"location":"Installation/#are-you-a-user","title":"Are You a User?","text":"<p>Be sure to read the rest of the wiki for how to use the app.</p> <p> Typical Usage</p> <p>SDK Problems?</p> <p>Perhaps the SDK installation had some issues.  Check out the FAQ on the topic</p>"},{"location":"Installation/#are-you-a-developer","title":"Are You a Developer?","text":"<p>There are a lot of resources on how to get started creating a patcher</p> <p> Create a Patcher</p>"},{"location":"Language-Settings/","title":"Language Settings","text":"<p>Synthesis comes with a few profile settings to help users that are targeting a language besides English.  The typical settings you should pick depend on your situation and the patterns that your language translation mods have used.</p>"},{"location":"Language-Settings/#overview","title":"Overview","text":""},{"location":"Language-Settings/#localize","title":"Localize","text":"<p>This setting controls whether to use <code>.STRINGS</code> file system when exporting your synthesis patches.  This will allow for a synthesis patch to export with multiple languages at once and with their associated preferred encoding, as each language is stored in their own files.</p>"},{"location":"Language-Settings/#language-dropdown","title":"Language Dropdown","text":"<p>This determines what language a mod which is not localized (does not have .strings files) should be considered to have.  This is important for different reasons depending on if you have the above Localized setting turned on: - If you have the above Localization setting turned on, when patchers have records from mods that were originally not localized, their string will be placed into the language strings file specified in this dropdown. - If you have the above Localization setting turned off, then when patchers have records from mods that were originally localized, it will take the language data from the strings file associated with the language from this dropdown and put that into the outgoing non-localized patch files.</p>"},{"location":"Language-Settings/#use-utf8-for-embedded-strings","title":"Use UTF8 for Embedded Strings","text":"<p>By default, if Localization is turned off for a mod and .strings files are not used, the embedded strings are encoded with a non-UTF8 encoding.  But, some language modding setups have mods with non-localized strings that are stored as UTF8 (often Japanese, Chinese, etc).  This setting controls whether Synthesis should use UTF8 when reading embedded strings or not.   For default English users, this is usually good to keep off.</p>"},{"location":"Language-Settings/#typical-recommended-settings","title":"Typical Recommended Settings","text":""},{"location":"Language-Settings/#for-english-users","title":"For English Users","text":"<p>Default settings is good:</p> <ul> <li><code>Localization</code> -&gt; Off</li> <li><code>Language Dropdown</code> -&gt; English</li> <li><code>Use UTF8 for Embedded Strings</code> -&gt; Off</li> </ul>"},{"location":"Language-Settings/#for-non-english-users","title":"For Non-English Users","text":"<p>A current best practice is not yet ironed out (please feel free to swing by the discord and offer your experience and suggestions!). </p> <p>The desired settings depend on the ecosystem your language community has adopted.  For example, Japanese/Chinese translation mods have seemingly opted to not use <code>.strings</code> files, and instead embed their strings into non-localized files that store with the UTF8 encoding.  Thus, for those setups, you would want to turn off <code>Localization</code>, and turn on <code>Use UTF8</code>.  </p> <p>But that might not be consistent with other language ecosystems or your specific setup.  The best recommendation is to read the available settings and try to navigate what combination will work for your setup.  If you find what works for you, please give some feedback so that this documentation can be better filled out!</p>"},{"location":"LoadOrder/","title":"Load Order","text":"<p>Load Order can affect the results of Synthesis patches in a few ways.  In general, it is preferable for Synthesis patches to exist on the load order when running.  This allows you to control what content they consider when patching, as described below.</p> <p>Keep In Load Order</p> <p>You do not need to remove Synthesis files from your Load Order before rerunning.  Keep it present and enabled, and just rerun the patcher pipeline to replace the existing file with a new version.</p>"},{"location":"LoadOrder/#patches-only-consider-mods-earlier-in-the-load-order","title":"Patches Only Consider Mods Earlier in the Load Order","text":"<p>A patch being run will only consider the mods that come before it in the load order.  Any mods that come after it are ignored and not seen or considered by the patchers when they are running.</p> <p>For example: <pre><code>ModA.esp\nSynthesis.esp\nModB.esp\n</code></pre></p> <p>If a patch pipeline for <code>Synthesis.esp</code> was run, <code>ModA.esp</code>'s contents would be considered while <code>ModB.esp</code> would be ignored.</p>"},{"location":"LoadOrder/#patch-not-on-load-order","title":"Patch Not On Load Order","text":"<p>If Group being run is not on the load order, then it is considered to be last and will consider everything on the load order.</p>"},{"location":"LoadOrder/#building-on-previous-patches","title":"Building On Previous Patches","text":"<p>Do patchers consider any other patcher's results when running?  </p>"},{"location":"LoadOrder/#within-a-group","title":"Within a Group","text":"<p>Patchers within a group build on each other's contents.  An earlier patcher's changes will affect a later patcher's results.</p> <p></p> <p>In this scenario, <code>Speed and Reach Fixes</code> will run first.  Any changes it makes will be seen and considered as <code>Facefixer</code> and <code>AmmoTweaks</code> run right after.</p> <p>Similarly, <code>FaceFixer</code>'s adjustments will be seen by <code>AmmoTweaks</code> which will make the final adjustments before exporting to <code>Synthesis.esp</code></p> <p>Occasionally, ordering will matter, as some patcher might want to act on the content that another creates. </p>"},{"location":"LoadOrder/#between-groups","title":"Between Groups","text":"<p>Group interaction works slightly differently.  Groups see previous Groups' results as if they were a normal mod on the load order.  So the initial Load Order example takes effect.</p> <p>For example: <pre><code>ModA.esp\nPatch1.esp\nPatch2.esp\nModB.esp\n</code></pre></p> <p><code>Patch1</code>'s run will consider <code>ModA.esp</code> when running, and nothing else.</p> <p><code>Patch2</code>'s run will see <code>ModA.esp</code> and also the results of <code>Patch1</code>, as it is a \"mod\" before it in the load order.</p> <p><code>ModB.esp</code> will not be considered by either, as it is later in the load order.</p>"},{"location":"LoadOrder/#group-order-should-match-load-order","title":"Group Order Should Match Load Order","text":"<p>It is important to note that generally Groups should be run in the same order they appear on the load order. </p> <p>Mismatched Order Leads to Bugs</p> <p>Running patcher groups in a different order than they appear on the load order can result in inconsistent output</p> <p>For example, if the Synthesis groups are listed: <pre><code>GroupA\nGroupB\n</code></pre> But are listed in your load order as: <pre><code>GroupB.esp\nGroupA.esp\n</code></pre> Then the following will occur:</p> <ul> <li>GroupA will run first</li> <li>GroupA will see GroupB's contents, but stale from the previous run</li> <li>GroupB will run second, and perhaps change its contents</li> </ul> <p>The result is that A has now built itself on an outdated understanding of B.  This may or may not mean the results will not be as expected, and a 2nd run will suddenly \"fix\" the issue as now A will see B's new results.</p> <p>Instead, it is recommended to keep the ordering in sync, unless you plan to run the groups independently in some special custom setup.</p>"},{"location":"Local-Solution-Patcher/","title":"Local Solution Patcher","text":"<p>This style uses a local C# project which is compiled and run as a patcher.</p> <p></p>"},{"location":"Local-Solution-Patcher/#goals-and-reasons-to-choose","title":"Goals and Reasons to Choose","text":"<ul> <li>Preferred route any time you want to run raw code from a folder that you downloaded/created yourself</li> <li>Can create new patcher Solutions/Projects or latch on to existing projects<ul> <li>Generated solutions come with a lot of initial settings configured for you, such as Nullability errors.</li> </ul> </li> <li>Code can be developed in an IDE on the side, but run from within Synthesis as part of a larger patcher pipeline. </li> <li>Meta information tooling is offered to customize the patcher's information such as descriptions/nicknames/visibility in the patcher browser</li> </ul> <p>Preferred for Developers, When Needed</p> <p>While this is the preferred patcher choice for developers, note that running during normal development should be done from your IDE, and not through the Synthesis UI</p> <p> Running a Patcher</p>"},{"location":"Local-Solution-Patcher/#required-input","title":"Required Input","text":"<p>The basic input required is:</p> <ul> <li>Path to a solution</li> <li>A dropdown of related projects will populate, of which one should be chosen.</li> </ul>"},{"location":"Local-Solution-Patcher/#new-patcher-wizard","title":"New Patcher Wizard","text":"<p>Synthesis is able to construct new patcher projects for you that contain a lot of starting frameworks and default settings.</p> <p></p> <p>It is able to construct whole Solutions from scratch, or add a new project to an existing solution, or latch onto existing projects.</p>"},{"location":"Local-Solution-Patcher/#patcher-settings","title":"Patcher Settings","text":"<p>A patcher has a Synthesis specific meta file where you can specify patcher description, among other things.  The Solution Patcher has built in GUI controls for modifying/creating this file:</p> <p></p> <p>Settings you can modify:</p> <ul> <li>Patcher display name</li> <li>One line description</li> <li>Multi-line extended description</li> <li>Whether to show in the patcher browser by default</li> </ul>"},{"location":"Multiple-Output-Targets/","title":"Multiple Output Targets","text":"<p>By default, Synthesis comes with one large group, named Synthesis.  Putting patchers inside and running them results in all of their content being added to one single mod named <code>Synthesis.esp</code>.</p>"},{"location":"Multiple-Output-Targets/#synthesis-groups","title":"Synthesis Groups","text":"<p>Synthesis can also be set up to export different patcher results into different mods. Synthesis groups is a feature that helps organize what patchers will go into what mod files.</p> <p>Each group will export its contained patchers into a mod with the name of the group. A group named <code>MyPatch</code> will be exported to a mod called <code>MyPatch.esp</code></p>"},{"location":"Multiple-Output-Targets/#adding-a-group","title":"Adding a Group","text":"<p>Clicking the new group button will add a fresh group to your pipeline</p> <p></p>"},{"location":"Multiple-Output-Targets/#renaming-a-group","title":"Renaming a Group","text":"<p>After creating a new Group, you will want to give it a name before it is usable.  This can only be done by focusing the group and renaming it in the right side panel</p> <p></p>"},{"location":"Multiple-Output-Targets/#adding-patchers-to-group","title":"Adding Patchers to Group","text":"<p>With the group selected, you can then add patchers to the new group as normal.  Just make sure to click on the group you want to add the patcher to before adding the patcher.</p>"},{"location":"Multiple-Output-Targets/#moving-patchers-between-groups","title":"Moving Patchers between Groups","text":"<p>You can also drag drop patchers between groups, and reorder them if the patchers you're choosing care about order.</p>"},{"location":"Multiple-Output-Targets/#running-with-multiple-groups","title":"Running With Multiple Groups","text":""},{"location":"Multiple-Output-Targets/#run-whole-pipeline","title":"Run Whole Pipeline","text":"<p>You can run the whole pipeline by clicking the run button at the bottom left of the UI.  This will run all of your groups in order one after another.</p> <p>Keep Groups In Sync With Load Order</p> <p>Group order must match load order Read More</p>"},{"location":"Multiple-Output-Targets/#running-a-single-group","title":"Running a Single Group","text":"<p>You can also run a single group in isolation, rather than generating all groups at once.  This is sometimes useful, but generally is less safe than running the whole pipeline.  </p>"},{"location":"Other-Dynamic-Mod-Generators/","title":"Other Dynamic Mod Generators","text":"<p>When running with other programs that generate content, there are two styles:</p>"},{"location":"Other-Dynamic-Mod-Generators/#ones-that-respect-load-order","title":"Ones that respect load order","text":"<p>If the program only considers content before it in the load order (Synthesis itself is in this category), then the only thing that matters is that the order you run the programs should match the order they appear in the load order</p> <p>If this is your load order: <pre><code>OtherProgramThatRespectsLoadOrder.esp\nSynthesis.esp\n</code></pre> Then run the other program first, followed by Synthesis.  If they're reversed, then you'd run them reversed.</p>"},{"location":"Other-Dynamic-Mod-Generators/#ones-that-run-on-the-entire-load-order","title":"Ones that run on the entire load order","text":"<p>If the other program runs on the entire load order no matter what, then it is recommended to place Synthesis before that other program in the load order</p> <pre><code>Synthesis.esp\nOtherProgramThatRunsOnEntireLoadOrder.esp\n</code></pre> <p>You would then run Synthesis first, and then the other program.   Synthesis would regenerate without considering the other program's content, and then the other program would build on top.</p>"},{"location":"Other-Dynamic-Mod-Generators/#specific-recommendations","title":"Specific Recommendations","text":""},{"location":"Other-Dynamic-Mod-Generators/#bashed-patch","title":"Bashed Patch","text":"<p>Probably good to run before Synthesis in the load order.  It processes leveled lists and might undesirably revert changes made by Synthesis patchers depending on the contexts.</p>"},{"location":"Patcher-Settings/","title":"Patcher settings","text":"<p>Typically, the settings file will end up here:</p> <p><code>[Path To The Synthesis Exe]/Data/[Profile Name]/[Patcher Name]/</code></p>"},{"location":"Patcher-Settings/#instructions","title":"Instructions","text":"<p>Each patcher is different and can be coded by the developers to get input from the user however they see fit.  It is recommended to check the instructions provided with each patcher for any details or extra instructions.</p>"},{"location":"Patcher-Settings/#embedded-settings-ui","title":"Embedded Settings UI","text":"<p>Synthesis as an ecosystem provides an easy way for patcher developers to hook into a settings UI within Synthesis itself.  </p> <p></p> <p>Some patchers might use this area for their settings, but not all will.</p>"},{"location":"Patcher-Settings/#open-for-settings","title":"Open For settings","text":"<p>Some patchers that are more advanced will make thier own UIs.  Synthesis can open them from the same area it displays its own settings.</p> <p></p> <p>This will open the patcher's own UI over the Synthesis UI.</p>"},{"location":"Sharing/","title":"Sharing Your Setup","text":"<p>So you have a good set of patchers and settings that you want to share!</p>"},{"location":"Sharing/#use-the-profile-export","title":"Use the Profile Export","text":"<p>The profile area has a dedicated button for exporting a copy of your Synthesis settings, specialized for sharing with others.</p> <p></p> <p>You can then give others those settings instead, which will have a few tweaks to help ensure they get the same setup you intended to pass on to them.</p>"},{"location":"Sharing/#automatic-update-settings-turned-off","title":"Automatic Update Settings Turned Off","text":"<p>All automatic update settings are turned off, such as following the target branch's latest commit automatically.</p> <p>This helps ensure people download the same version you were using at the time of export, without any unexpected auto updates.</p>"},{"location":"Sharing/#lock-to-current-versioning-turned-on","title":"Lock To Current Versioning Turned On","text":"<p>There is a setting in the profile area named \"Lock to Current Versioning\".  This is turned on, which blocks interaction with any versioning settings, and hides all blue update arrows.  This helps discourage users that might be tempted to just click all the update buttons as soon as they open Synthesis.</p>"},{"location":"Sharing/#clears-out-other-profiles","title":"Clears Out Other Profiles","text":"<p>Other profiles besides the one selected are trimmed out, so that only the profile you meant to pass off gets included.</p>"},{"location":"Sharing/#other-tweaks-in-the-future","title":"Other Tweaks in the Future","text":"<p>As other settings come out, they will appropriately be tweaked for Export when using this feature to work best for handing off to other users.</p>"},{"location":"Starting-Into-Profile/","title":"Starting Into a Specific Profile","text":"<p>Synthesis can be started with command line parameters to have it open to a specific profile:</p> <p><code>-p ProfileName</code></p> <p>Using this, you can have different Mo2 profiles drive Synthesis to open with a specific associated profile</p>"},{"location":"Synth-File/","title":".synth Files are Installer Files","text":"<p><code>.synth</code> files can be made to be \"installer\" files for patchers.  Users can double click a <code>.synth</code> file to have a patcher added to the currently selected group in the Synth UI.</p>"},{"location":"Synth-File/#using-a-synth-file-to-install-a-patcher","title":"Using a .synth File to Install a Patcher","text":"<ul> <li>Open Synthesis UI</li> <li>Click on the group you want the patcher added to</li> <li>Double click and open the <code>.synth</code> file</li> </ul>"},{"location":"Synth-File/#creating-an-installer-synth-file","title":"Creating an Installer .synth File","text":"<p>To create a .synth file, create a text file with the repository url and project location that normally shows up. Then make sure to save your file as <code>[patcher_name].synth</code>.</p> <pre><code>{\n  \"AddGitPatcher\": \n  {\n    \"Url\": \"https://github.com/[Project-Path]\",\n    \"SelectedProject\": \"[Directory]\\\\[Project].csproj\"\n  }\n}\n</code></pre> <p>Users should then be able to use this shortcut that to add your patcher to Synthesis.</p>"},{"location":"Synthesis-CLI/","title":"Synthesis CLI","text":"<p>Synthesis offers a CLI alternative to the UI.  This can be useful for Linux users, or anyone else that wants to do operations without the UI.</p>"},{"location":"Synthesis-CLI/#run-pipeline","title":"Run Pipeline","text":"<p><code>run-pipeline</code></p> <p>Runs the Synthesis pipeline on all the groups for a specific profile.</p>"},{"location":"Synthesis-CLI/#typical","title":"Typical","text":"<p><code>.\\Path\\To\\Synthesis.CLI.exe run-pipeline --OutputDirectory \"C:\\Games\\steamapps\\common\\Skyrim Special Edition\\Data\" --PipelineSettingsPath \".\\Path\\To\\PipelineSettings.json\" --ProfileIdentifier \"NameOfProfile\"</code></p>"},{"location":"Synthesis-CLI/#parameters","title":"Parameters","text":"Short Long Required Description <code>-o</code> <code>--OutputDirectory</code> Required Path where the patcher should place its resulting file(s). <code>-s</code> <code>--PipelineSettingsPath</code> Required Path to a specific pipeline settings to read from <code>-d</code> <code>--DataFolderPath</code> Optional Path to the data folder. <code>-p</code> <code>--ProfileIdentifier</code> Semi-Optional Nickname/GUID of profile to run if path is to a settings file with multiple profiles <code>-l</code> <code>--LoadOrderFilePath</code> Optional Path to the load order file to use. <code>-e</code> <code>--ExtraDataFolder</code> Optional Path to where top level extra patcher data should be stored/read from.  Default is next to the exe <code>-r</code> <code>--PersistencePath</code> Optional Path to the shared FormKey allocation state <code>-m</code> <code>--PersistenceMode</code> Optional Path to the Persistence state style to use <code>-t</code> <code>--TargetRuntime</code> Optional Target runtime to specify explicitly"},{"location":"Synthesis-CLI/#create-profile","title":"Create Profile","text":"<p><code>create-profile</code></p> <p>Creates a new profile and saves it to the settings</p>"},{"location":"Synthesis-CLI/#typical_1","title":"Typical","text":"<p><code>.\\Path\\To\\Synthesis.CLI.exe create-profile --GameRelease SkyrimSE --ProfileName \"New Profile Name\" --InitialGroupName \"New Group Name\" --PipelineSettingsPath \".\\Path\\To\\PipelineSettings.json\"</code></p>"},{"location":"Synthesis-CLI/#parameters_1","title":"Parameters","text":"Short Long Required Description <code>-r</code> <code>--GameRelease</code> Required Game release that the profile should be related to <code>-p</code> <code>--ProfileIdentifier</code> Semi-Optional Nickname/GUID of profile to run if path is to a settings file with multiple profiles <code>-g</code> <code>--InitialGroupName</code> Required Name to give the initial patcher group <code>-s</code> <code>--PipelineSettingsPath</code> Required Path to a specific pipeline settings to target"},{"location":"Synthesis-CLI/#add-git-patcher","title":"Add Git Patcher","text":"<p><code>add-git-patcher</code></p> <p>Adds a Git patcher to a profile and saves it to the settings.</p> <p>Main parameters are the Github URL address of the patcher to add, as well as the project subpath.  The project subpath is the subpath needed to go from the top folder of the patcher's source code to the <code>.csproj</code> to run as the patcher.</p>"},{"location":"Synthesis-CLI/#typical_2","title":"Typical","text":"<p><code>.\\Path\\To\\Synthesis.CLI.exe add-git-patcher --ProfileIdentifier \"Profile Name\" --GroupName \"Group Name\" --GitRepoAddress \"UrlOfPatcherGithub\" --ProjectSubPath \"Project/Project.csproj\" --PipelineSettingsPath \".\\Path\\To\\PipelineSettings.json\"</code></p>"},{"location":"Synthesis-CLI/#parameters_2","title":"Parameters","text":"Short Long Required Description <code>-p</code> <code>--ProfileIdentifier</code> Semi-Optional Nickname/GUID of profile to add to if path is to a settings file with multiple profiles <code>-g</code> <code>--GroupName</code> Required Name of the patcher group to add the patcher to <code>-s</code> <code>--PipelineSettingsPath</code> Required Path to a specific pipeline settings to target <code>-a</code> <code>--GitRepoAddress</code> Required URL address to the repository to add the git patcher from <code>--ProjectSubpath</code> Required Project subpath to target <code>--PatcherNickname</code> Optional Nickname to give the patcher's entry"},{"location":"Synthesis-CLI/#add-solution-patcher","title":"Add Solution Patcher","text":"<p><code>add-solution-patcher</code></p> <p>Adds a Solution patcher to a profile and saves it to the settings.</p>"},{"location":"Synthesis-CLI/#typical_3","title":"Typical","text":"<p><code>.\\Path\\To\\Synthesis.CLI.exe add-solution-patcher --ProfileIdentifier \"Profile Name\" --GroupName \"Group Name\" --SolutionPath \".\\Path\\To\\Solution.sln\" --ProjectSubPath \"Project/Project.csproj\" --PipelineSettingsPath \".\\Path\\To\\PipelineSettings.json\"</code></p>"},{"location":"Synthesis-CLI/#parameters_3","title":"Parameters","text":"Short Long Required Description <code>-p</code> <code>--ProfileIdentifier</code> Semi-Optional Nickname/GUID of profile to add to if path is to a settings file with multiple profiles <code>-g</code> <code>--GroupName</code> Required Name of the patcher group to add the patcher to <code>-s</code> <code>--PipelineSettingsPath</code> Required Path to a specific pipeline settings to target <code>--SolutionPath</code> Required Path to the solution to target <code>--ProjectSubpath</code> Required Project subpath to target <code>--PatcherNickname</code> Optional Nickname to give the patcher's entry"},{"location":"Synthesis-CLI/#create-template-patcher","title":"Create Template Patcher","text":"<p><code>create-template-patcher</code></p> <p>Create a new patcher project template for a developer to start creating a new patcher.  This is a new folder with a csproj, solution, and other related bits to getting started developing a new patcher.</p>"},{"location":"Synthesis-CLI/#typical_4","title":"Typical","text":"<p><code>.\\Path\\To\\Synthesis.CLI.exe create-template-patcher --GameCategory Skyrim --ParentDirectory \"Path\\To\\Some\\Dir\" --PatcherName \"My First Patcher\"</code></p>"},{"location":"Synthesis-CLI/#parameters_4","title":"Parameters","text":"Short Long Required Description <code>-c</code> <code>--GameCategory</code> Required Game category that the patcher should be related to <code>-d</code> <code>--ParentDirectory</code> Required Parent directory to house new solution folder <code>-n</code> <code>--PatcherName</code> Required Name to give patcher"},{"location":"Synthesis-vs-Mutagen/","title":"Synthesis vs Mutagen","text":"<p>Often newcomers are first introduced to Synthesis.  They install a patcher or want to make their own. But what is the term Mutagen, and why is it mentioned often alongside Synthesis?</p> <p>Both of these terms are used in conjunction with each other often, and so they can get confusing.</p>"},{"location":"Synthesis-vs-Mutagen/#mutagen","title":"Mutagen","text":"<p>Mutagen is the library that allows for reading and manipulating Bethesda plugin files.  </p> <p>Sorts of things that Mutagen is in charge of:</p> <ul> <li>Reading what an Npc's Health is</li> <li>Making 10 new Weapons with various stats</li> <li>Finding/reading a texture asset from a BSA</li> <li>Resolving and finding the Race that an Npc is</li> <li>Other jobs that require interacting with mods and analyzing/manipulating their data</li> <li>Creating or modifying mod files</li> </ul>"},{"location":"Synthesis-vs-Mutagen/#synthesis","title":"Synthesis","text":"<p>Synthesis is a system that is built on top of Mutagen to provide an easy patcher pipeline ecosystem.  </p> <p>Things that Synthesis is in charge of:</p> <ul> <li>Running dozens of Mutagen code snippets (patchers) from many mod authors easily in one place with one click</li> <li>A UI for users to control what patchers they want to install, in what groups, in what order.</li> <li>Creating an easy bootstrap project template that hooks into the Synthesis system for developers to start coding</li> <li>Keeping all the code in sync with the latest mutagen versions</li> </ul>"},{"location":"Synthesis-vs-Mutagen/#summary","title":"Summary","text":"<p>Synthesis is the patcher pipeline ecosystem that helps create an accessible environment for developers to create and for users to run Mutagen code snippets.   You do not need to find/install Mutagen yourself as an installation step for Synthesis, it will be pulled in automatically.</p>"},{"location":"Typical-Usage/","title":"Typical Usage","text":"<p>This clip is a good visual example of typical usage, but this page will be going over it in more detail.</p> <p></p>"},{"location":"Typical-Usage/#adding-patchers","title":"Adding Patchers","text":""},{"location":"Typical-Usage/#select-a-patcher-type","title":"Select a Patcher Type","text":"<p>There are a few alternatives, but the one recommended for new users is the Git Repository patcher.</p> <p></p>"},{"location":"Typical-Usage/#installing-a-git-patcher","title":"Installing a Git Patcher","text":""},{"location":"Typical-Usage/#browse","title":"Browse","text":"<p>You can either look around in the wild yourself, or you can make use of the built in list of existing patchers.  Within a <code>Git Repository</code> patcher, there is a <code>Browse</code> section with an automatically populated list:</p> <p></p> <p>Automatically Populated</p> <p>This list is automatically populated via a Synthesis Registry</p>"},{"location":"Typical-Usage/#input-tab","title":"Input Tab","text":"<p>If you have a specific github address you want to use you can paste it directly into the <code>Input</code> tab.</p>"},{"location":"Typical-Usage/#synth-files","title":".synth files","text":"<p>Synthesis patchers can be distributed via <code>.synth</code> files.  These files simply instruct the program to add the patcher as if you did the above steps.  </p> <p>To use a <code>.synth</code> file:</p> <ul> <li>Open Synthesis</li> <li>Select the group you want to add the patcher to.  Initially there is only one, so you can skip this step</li> <li>Double click the <code>.synth</code> file on the desktop</li> </ul> <p></p> <p> .synth Files</p>"},{"location":"Typical-Usage/#patcher-settings","title":"Patcher Settings","text":"<p>Some patchers either require extra input, or offer customization options.  Some use the settings panel within Synthesis itself, while others use extra json files.</p> <p></p> <p>Read more about how settings are handled in Synthesis</p> <p> Patcher Settings</p> <p>Each Patcher is Different</p> <p>Each patcher can expose their settings files however they like, and not all patchers have settings.  Refer to the specific patcher's documentation.</p>"},{"location":"Typical-Usage/#patcher-versioning","title":"Patcher Versioning","text":"<p>Synthesis can artificially upgrade patchers to newer versions of Mutagen to get fixes and upgrades locally, even if the original developers haven't updated in a while.  </p> <p> Recommended Versioning Setup</p> <p>The recommended setup will give you precise control over when you upgrade, while allowing you to revert patchers that have problems running into hyper compatibility mode.</p>"},{"location":"Typical-Usage/#running-the-patcher-pipeline","title":"Running the Patcher Pipeline","text":"<p>Once you have a list of patchers, you can run them to create a single <code>Synthesis.esp</code> patch file which will contain all the changes from the patchers.  </p> <p></p> <p>You can click on any specific patcher to see specifics about it, or any errors it may have printed. </p> <p>Running the pipeline will export a file per patcher group to your <code>Data</code> folder.</p> <p> Customizing Data Folder Location</p> <p> Multiple Output Files</p> <p>Mod Manager Interception</p> <p>Some mod managers like Mo2 \"intercept\" new files.  If there are no errors in Synthesis, but you're not seeing its output in the Data folder, then your mod manager might be intercepting.</p>"},{"location":"Typical-Usage/#enable-in-your-load-order","title":"Enable in your Load Order","text":"<p>Once a patch is created, you'll want to use your favorite tool to view the results (like xEdit) and then add the patch to your load order!</p> <p>You do not need to remove Synthesis from your Load Order before rerunning.  Keep it present and enabled, and just rerun the patcher pipeline to replace the existing file with a new version.</p> <p> Load Order</p>"},{"location":"Typical-Usage/#read-the-rest-of-the-wiki","title":"Read The Rest of the Wiki","text":"<p>This page is just a brief overview of how to get started.  Be sure to read the rest of the wiki!</p>"},{"location":"Updating-UI/","title":"Updating the Synthesis UI","text":"<p>There are a few Versioning concepts within the Synthesis ecosystem, but the UI itself should generally be kept up to date with the newest version.</p>"},{"location":"Updating-UI/#update-net-sdk","title":"Update .Net SDK","text":"<p>If the Installation Instructions have updated, you might need to install the newest .Net SDK</p>"},{"location":"Updating-UI/#updating-the-ui","title":"Updating the UI","text":"<ul> <li>Go to Releases and download the latest stable version.</li> <li>Optionally back up your settings.  This includes:<ul> <li><code>[UI Exe Location]/PipelineSettings.json</code></li> <li><code>[UI Exe Location]/GuiSettings.json</code></li> <li><code>[UI Exe Location]/Data/</code></li> </ul> </li> <li>Unzip the release zip</li> <li>Overwrite the old Synthesis files</li> <li>Can also opt to keep the new version in a new area, but you will want to copy over the settings mentioned above</li> </ul>"},{"location":"Versioning/","title":"Versioning","text":"<p>Synthesis has a few distinct versioning concepts.  These are important for understanding what code will be run when making your patches.</p>"},{"location":"Versioning/#ui-version","title":"UI Version","text":"<p>Synthesis itself has an exe that is the GUI that you interact with.  The version the UI is running is what is listed at the top right of the window.</p> <p></p> <p>This picture shows a UI that is <code>0.21.2</code></p> <p>Use the newest UI</p> <p>The UI should usually always be the newest stable version available.  Only in rare circumstances might you want to downgrade it if some bug was encountered, and a hotfix hadn't been released yet.</p>"},{"location":"Versioning/#git-patcher-versioning","title":"Git Patcher Versioning","text":"<p>This section outlines the various ways a specific Git Patcher's versioning can controlled.   As this is the most commonly used patcher, it is an important topic.</p>"},{"location":"Versioning/#libraries-to-use","title":"Libraries to Use","text":"<p><code>Mutagen</code> and <code>Synthesis</code> are also code libraries that patchers use to develop their logic.  Depending on which version a patcher uses when running, it might get certain fixes/improvements/features.</p> <ul> <li><code>Mutagen</code> library that allows mods to read and write <code>esp</code> files and other similar tasks</li> <li><code>Synthesis</code> library that helps bootstrap a project to easily hook into the UI and be runnable by users.</li> </ul> <p>Each patcher in Synthesis' UI comes with controls to modify what versions of the libraries a patcher will be run with.</p> <p></p>"},{"location":"Versioning/#recommended-setup","title":"Recommended Setup","text":"<p>The recommended setup for patcher versioning is:</p> <ul> <li>In profile settings, set to <code>Manual</code></li> <li>Press <code>Reset Patchers to Profile</code>, if you want to snap them all to follow the profile settings.</li> <li>Hit the blue upgrade button to upgrade Mutagen/Synth to newest at your leisure when it makes sense for you</li> <li>Any single patchers that can't run can be individually set to <code>Match</code> for maximum compatibility</li> </ul> <p></p>"},{"location":"Versioning/#profile","title":"Profile","text":"<p>Recommended</p> <p>This is the recommended choice for individual patchers Read More</p> <p>This option is only available on individual patchers, and helps keeps all of your patchers in sync.  The profile settings will have one single versioning choice, and all patchers set to <code>Profile</code> will follow along automatically.   This allows easy control from one location.</p> <p></p>"},{"location":"Versioning/#manual","title":"Manual","text":"<p>Recommended</p> <p>Manual is the best balance between control and convenience. It is the recommended default choice for a profile's versioning settings Read More</p> <p>Sets the patcher to use a specific version, while allowing the user to easily update to latest when desired.</p> <p>Pros:</p> <ul> <li>Follows latest easily, while giving you a heads up and control over timing</li> </ul> <p>Cons:</p> <ul> <li>Depending on the versions you input and the age of the patcher, it may not compile</li> </ul> <p></p>"},{"location":"Versioning/#match","title":"Match","text":"<p>Compatibility Fallback Choice</p> <p>Only set patchers to Match if they are having problems running</p> <p>Use whatever versions were listed explicitly by the patcher.</p> <p>Each patcher is coded at a certain point in time.  The developer will typically work with the newest versions when develop their patcher.  As time progresses this listed version will become \"old\" as newer versions of <code>Mutagen</code> or <code>Synthesis</code> get released.</p> <p>By setting a patcher to <code>Match</code>, you are telling a patcher to use the same versions it was originally coded with.  This will be the most compatible, but might miss out on some necessary bugfixes.</p> <p>Pros:</p> <ul> <li>More stable, as these were the versions used when the patcher was developed</li> </ul> <p>Cons:</p> <ul> <li>Won't have any fixes or optimizations that came later on</li> </ul>"},{"location":"Versioning/#latest","title":"Latest","text":"<p>Unexpected Updates</p> <p>If you want a consistent patch every time you run, you don't want to use this option</p> <p>This will upgrade the patcher to use the latest version of Mutagen/Synthesis libraries automatically.  It's usually recommended to avoid using this, in favor of <code>Manual</code>, which lets you click the upgrade buttons yourself so you know when things are being upgraded.</p> <p>Pros:</p> <ul> <li>Get the latest features/fixes/optimizations right as they come out</li> </ul> <p>Cons:</p> <ul> <li>The resulting patch might change at any time if a patcher updates and changes its logic.</li> <li>Depending on the age of the patcher, it may not compile</li> </ul>"},{"location":"Versioning/#using-prerelease-versions","title":"Using Prerelease Versions","text":"<p>Sometimes you might want to use a new experimental version of the libraries.  To allow this, check the <code>Prerelease</code> checkbox in the profile settings</p> <p></p>"},{"location":"Versioning/#patcher-code-to-run","title":"Patcher Code to Run","text":"<p>The last aspect of versioning is the patcher code itself.  This is the code the developer wrote -using- <code>Mutagen</code> and <code>Synthesis</code> to accomplish a specific goal.  There are a few options available for controlling what patcher code you want to be run.</p> <p>Most of the concepts here are <code>Git</code> concepts and lingo, which is the system that helps version code and let you \"travel back in time\" to past states.</p>"},{"location":"Versioning/#branch","title":"Branch","text":"<p>Branches are nicknamed trails of code over time.  Typically the <code>main</code> branch has the most stable code, while other branches like <code>dev</code> might exist with more experimental work, but it is up to the patcher developer.</p> <p>By choosing <code>Branch</code> and providing a name, you are instructing Synthesis to follow that named path of code.  If a developer pushes new code to a branch, Synthesis will want to update and follow along.</p> <p></p> <p>Recommended</p> <p><code>Branch</code> mode, with <code>Auto -&gt; Off</code>, and <code>Main -&gt; On</code> is the recommended setup</p> <p>On the left you can see the name of the branch being followed: <code>master</code></p> <p>The <code>Auto</code> checkbox will control whether to follow the branch automatically, or notify you with a blue arrow when one is available.  In this picture, <code>Auto</code> is off, and so the UI is showing a blue arrow offering to update.</p> <p>The <code>Main</code> checkbox locks the name of the branch to whatever the patcher decides is its main branch.  This avoids the need to type in the exact branch name by hand.  If you want to switch to another branch, you will need to uncheck this <code>Main</code> box, which will allow you to type in the alternative branch name.</p>"},{"location":"Versioning/#tag","title":"Tag","text":"<p>A tag is a nicknamed state of the code at a specific point in time.  Typically it will never move, and will always refer to the same code.  Often tags will be named things like <code>v1.1</code>, <code>v1.2</code>, and represent discrete versions of the code to choose from.</p> <p></p> <p>You can type in the name of the tag that you would like to use, and then press the blue arrow to update to that tag.</p> <p>If the patcher developer has named their tags like versions, then Synthesis can be set to <code>Auto</code> and will update to the latest tag whenever one is released.</p> <p>Not Always Available</p> <p>It is up to the developer to stamp tags if they would like to.  They may not decide to do so, and so this option will not be viable.</p>"},{"location":"Versioning/#commit","title":"Commit","text":"<p>A commit is a specific point in time.  By specifying a single commit, you are instructing Synthesis to use the code as it existed at a very specific point in time.</p> <p></p> <p>This type of extreme control is typically not needed.   The use cases for using <code>Commit</code> are:</p> <ul> <li>The patcher developer instructs you to do so to test something</li> <li>The patcher developer isn't maintaining the other options properly, and you know of a specific state of the code that you want to use.</li> </ul>"},{"location":"devs/Coding-a-Patcher/","title":"Coding a Patcher","text":""},{"location":"devs/Coding-a-Patcher/#starting-setup","title":"Starting Setup","text":"<p>If you used a Local Solution Patcher to Create a Patcher, then you will have a project that has a minimal basic setup:</p> <pre><code>public static async Task&lt;int&gt; Main(string[] args)\n{\n    return await SynthesisPipeline.Instance\n        .AddPatch&lt;ISkyrimMod, ISkyrimModGetter&gt;(RunPatch)\n        .SetTypicalOpen(GameRelease.SkyrimSE, \"YourPatcher.esp\")\n        .Run(args);\n}\n\npublic static void RunPatch(IPatcherState&lt;ISkyrimMod, ISkyrimModGetter&gt; state)\n{\n    //Your code here!\n}\n</code></pre>"},{"location":"devs/Coding-a-Patcher/#run-patch-method","title":"Run Patch Method","text":"<p>The <code>RunPatch</code> method is where the code for your patcher should be located.  It will be run when Synthesis is running a pipeline, as well as when your program is started standalone.  The method has access to the Synthesis State object, which has much of the information needed to run a patcher.  </p> <p>Whatever changes you want to be made should be applied to the <code>state.PatchMod</code> object.</p>"},{"location":"devs/Coding-a-Patcher/#synthesis-state-object","title":"Synthesis State Object","text":"<p>The state object given to your <code>RunPatch</code> contains several important objects:</p> <ul> <li>PatchMod: The export patch mod object that all changes should be applied to</li> <li>LoadOrder:  Object containing all the readonly mod objects on the load order</li> <li>LinkCache:  Link Cache created from the load order</li> <li>ExtraSettingsDataPath:  Path where any custom Internal Data will be located</li> </ul>"},{"location":"devs/Coding-a-Patcher/#typical-simple-code","title":"Typical Simple Code","text":"<p>Typical code for a Synthesis patcher consists of locating Winning Overrides for a record type, and adding them to the output patch mod with some changes.  Here is a simplistic example:</p> <pre><code>// Loop over all the winning NPCs in the load order\nforeach (var npcGetter in state.LoadOrder.PriorityOrder.Npc().WinningOverrides())\n{\n    // See if it is a Goblin \n    if (!npcGetter.EditorID?.Contains(\"Goblin\", StringComparison.OrdinalIgnoreCase) ?? true) continue;\n\n    // Add it to the patch\n    var npc = state.PatchMod.Npcs.GetOrAddAsOverride(npcGetter);\n\n    // Shrink\n    npc.Height /= 2;\n}\n</code></pre> <p>The above code will shrink any Goblin-named NPCs</p> <p>Two good resources for learning further details:</p> <ul> <li>A large catalogue of existing patchers to look at for examples</li> <li>In-depth Mutagen documentation found on the Mutagen wiki.</li> </ul>"},{"location":"devs/Configuring-a-Patcher-at-Startup/","title":"Configuring a Patcher at Startup","text":"<p>The main method of a patcher is dedicated to calling <code>SynthesisPipeline</code>, which is a builder that lets you customize how and what your patcher is going to run. </p> <pre><code>// A typical main method\npublic static async Task&lt;int&gt; Main(string[] args)\n{\n    return await SynthesisPipeline.Instance\n        .AddPatch&lt;ISkyrimMod, ISkyrimModGetter&gt;(RunPatch)\n        .SetTypicalOpen(GameRelease.SkyrimSE, \"YourPatcher.esp\")\n        .Run(args);\n}\n</code></pre> <p>The main method as created by the template system can be left as-is for a basic setup, but it can be customized to your needs from there.</p>"},{"location":"devs/Configuring-a-Patcher-at-Startup/#addpatch","title":"AddPatch","text":"<p>Adds a Game Category to be handled by your patcher, and lets you decide what function should be called when your patcher is being run for that game.  One <code>AddPatch</code> is generally required, as it's the entry point into your patcher for the game you want to target.</p>"},{"location":"devs/Configuring-a-Patcher-at-Startup/#patcherpreferences","title":"PatcherPreferences","text":"<p>This is an optional argument to an <code>AddPatch</code> call, which will customize some settings related to that Patch operation.</p> <ul> <li>IncludeDisabledMods:  Whether to include mods that are disabled on the LoadOrder object (default false)</li> <li>AddImplicitMasters:  Whether to enable masters that are listed as disabled, but required by an active mod</li> <li>NoPatch:  If toggled on, your patcher will skip the export step.  Useful if your patcher is just modifying other unrelated files only.</li> <li>Cancel:  (Advanced) If your app wants to be able to cancel an in-progress patching run, for some reason, a cancellation token can be given here.</li> <li>Inclusion/ExclusionMods:  (Untested) Allows whitelisting or blacklisting mods from the load order</li> </ul>"},{"location":"devs/Configuring-a-Patcher-at-Startup/#standalone-open-configuration","title":"Standalone Open Configuration","text":"<p>Determines what your patcher will do if it's run standalone, either via running the exe directly from the desktop, or more likely when running it from your IDE for testing.</p> <p>Renamed</p> <p>Will eventually be renamed to <code>SetStandaloneOpen</code></p>"},{"location":"devs/Configuring-a-Patcher-at-Startup/#target-mod-file","title":"Target Mod File","text":"<p>By default, the <code>SetTypicalOpen</code> is set to:</p> <ul> <li>Output into the typical data folder </li> <li>With a given mod name</li> <li>For a given Game Release</li> </ul> <pre><code>.SetTypicalOpen(GameRelease.SkyrimSE, \"YourPatcher.esp\")\n</code></pre>"},{"location":"devs/Configuring-a-Patcher-at-Startup/#arbitrary-code","title":"Arbitrary Code","text":"<p>You can also pass <code>SetTypicalOpen</code> any C# Action, which will give you the ability to run any code you want during standalone runs:</p> <pre><code>...\n.SetTypicalOpen(() =&gt;\n{\n    // Whatever code you want\n})\n</code></pre>"},{"location":"devs/Configuring-a-Patcher-at-Startup/#run","title":"Run","text":"<p>Capstone call to the SynthesisPipeline builder which takes in the arguments given to your app when it started and runs the patcher given the rules you've specified.  The program will do nothing if this is missing.</p>"},{"location":"devs/Configuring-a-Patcher-at-Startup/#setautogeneratedsettings","title":"SetAutogeneratedSettings","text":"<p>Associates a settings file with a settings object.   This allows you to get easy autogenerated settings provided by Synthesis.</p> <p>The main method just passes the arguments given your program to the Synthesis systems, which handles all the various commands that could be passed in.  Generally, the main method can be left as-is.</p>"},{"location":"devs/Configuring-a-Patcher-at-Startup/#addrunnabilitycheck","title":"AddRunnabilityCheck","text":"<p>Provides a callback to check if your patcher sees itself as having all the necessary things it needs to run, and block execution until those requirements are satisfied. Read More</p>"},{"location":"devs/Configuring-a-Patcher-at-Startup/#setopenforsettings","title":"SetOpenForSettings","text":"<p>This is a more advanced option, which allows your patcher to be opened as a settings editor.  It requires you to modify your patcher project a lot, so that it is simultaneously a patcher executable as well as a UI application.   If that is set up, then this call provides the entry point to know when to open your application as a UI for settings input.</p>"},{"location":"devs/Create-a-Patcher/","title":"Create a Patcher","text":""},{"location":"devs/Create-a-Patcher/#install-an-ide","title":"Install an IDE","text":"<p>Be sure to install an IDE for C# development!</p> <ul> <li>Visual Studio Community</li> <li>Rider</li> </ul> <p>You will also need the DotNet SDK, but this should come with the IDE.</p>"},{"location":"devs/Create-a-Patcher/#solution-patcher","title":"Solution Patcher","text":"<p>Synthesis provides bootstrapping functionality to get new Mutagen patchers off the ground fairly easily.</p> <p>These systems can be found by creating a new Local Solution patcher, which is the preferred patcher type for developers.</p> <p></p> <p>There is a few options available when creating a new Solution Patcher:</p> <ul> <li>New Solution and Project (for brand new setups)</li> <li>New Project (for adding another patcher to an existing repository)</li> <li>Existing (latch on to an existing setup)</li> </ul> <p>When creating a new patcher, Synthesis will construct and set up several default settings/files:</p> <ul> <li>Creates a solution</li> <li>Creates a project, with both Synthesis and Mutagen imported</li> <li>Creates a default main method, which is hooked into the standard Synthesis pipeline.</li> <li>Enables nullability compiler features, which are very important when utilizing Mutagen</li> <li>Default gitignore</li> <li>Hides/upgrades some specific error types</li> </ul> <p>Prefer IDE</p> <p>The solution patcher should not be used to execute your program during normal development.  Run through your IDE instead while you're writing code to get debugging features.</p> <p> Running a Patcher</p>"},{"location":"devs/Create-a-Patcher/#locating-the-code","title":"Locating the Code","text":"<p>The Local Solution Patcher can open your preferred IDE, or you can navigate and open the solution yourself.</p> <p>NOTE:  While the Synthesis UI helps make a new solution, once it's made, it is recommended to just open it with your IDE, and not use the Synthesis UI during active development.  Only use the Synthesis UI if you're interested in testing your patcher alongside other patchers (not usually interesting).</p> <p>A patcher project should have a <code>Program.cs</code> file with the initial Synthesis bootstrapping code already in place.</p> <pre><code>public static async Task&lt;int&gt; Main(string[] args)\n{\n    return await SynthesisPipeline.Instance\n        .AddPatch&lt;ISkyrimMod, ISkyrimModGetter&gt;(RunPatch)\n        .SetTypicalOpen(GameRelease.SkyrimSE, \"YourPatcher.esp\")\n        .Run(args);\n}\n\npublic static void RunPatch(IPatcherState&lt;ISkyrimMod, ISkyrimModGetter&gt; state)\n{\n    //Your code here!\n}\n</code></pre> <p>The main function calls Synthesis bootstrapping code that listens for commands from the Synthesis pipeline and calls your RunPatch code when appropriate.</p>"},{"location":"devs/Create-a-Patcher/#customization","title":"Customization","text":"<p>Patchers that are listed on the store use a meta json file to specify some customization.  The Local Solution Patcher can modify this file for you in the GUI itself.</p> <p></p> <ul> <li>Display Name</li> <li>One line description</li> <li>Long description</li> <li>Whether to show in the store by default</li> </ul>"},{"location":"devs/Create-a-Patcher/#more-topics","title":"More Topics","text":"<p> Coding a Patcher</p> <p> Running a Patcher</p>"},{"location":"devs/Internal-Data/","title":"Internal Data","text":"<p>Synthesis provides a side area if you have internal data that a patcher wants access to, but a user does not need to be aware of.</p>"},{"location":"devs/Internal-Data/#internal-data-folder","title":"Internal Data Folder","text":"<p>Create a folder named <code>InternalData</code> next to your <code>.csproj</code></p> <p><code>[Path To Solution Folder]/[Path To Project Folder]/InternalData/[... your files ...]</code></p> <p>Any files located in this folder will be accessible by your patcher</p>"},{"location":"devs/Internal-Data/#accessing-internal-data","title":"Accessing Internal Data","text":""},{"location":"devs/Internal-Data/#tryretrieve-off-state","title":"TryRetrieve off State","text":"<p>The Synthesis state object has convenience calls to access the internal data by providing the relative paths: <pre><code>// Perhaps pipe this to a Json/xml parser, etc\nvar pathToInternalFile = state.RetrieveInternalFile(\"The/Relative/PathYouGaveYourInternalData.exe\"));\n</code></pre> The path given should be relative to the <code>InternalData</code> folder, rather than absolute paths.</p> <p>The function returns the absolute path to the file, or throws with some informative messages if not.</p>"},{"location":"devs/Internal-Data/#manual","title":"Manual","text":"<p>The Synthesis state object also contains a <code>InternalDataPath</code> member that you can use to inspect and access internal files yourself with normal file API.</p>"},{"location":"devs/Nexus-Integration/","title":"Nexus Integration","text":"<p>Typically mods are uploaded straight to the Nexus.  However, Synthesis mods are code, which the Nexus isn't as suited for.  Places like GitHub are better homes for Synthesis patchers, as they come with all the tooling that coding developers rely on:</p> <ul> <li>Git based historical tracking</li> <li>Branches for experimental versions</li> <li>Easily browsable source code</li> <li>Ability for others to contribute fixes/upgrades as Pull Requests</li> </ul> <p>Additionally, the Synthesis system leverages these Git Patchers to fulfill many other features:</p> <ul> <li>Automatic listing in the Synthesis search systems</li> <li>Automatic upgrades over time via the Versioning System, which reduces the need for maintenance on your end.</li> </ul>"},{"location":"devs/Nexus-Integration/#create-a-synth-file","title":"Create a .Synth File","text":"<p>Synthesis offers a <code>.synth</code> file that acts as a convenience installer.   The concept is unnecessary if users are familiar with the Git Repository Browser systems.  However, for Nexus, it allows us to create a file that we can upload for our mod listing.</p> <p>Please refer to the .synth File page for more details</p>"},{"location":"devs/Nexus-Integration/#uploading-exes","title":"Uploading Exes","text":"<p>One alternative is to compile the exe yourself, and upload that to the Nexus.  This is undesirable for a few reasons:</p> <ul> <li>It cannot get upgraded with Mutagen/Synthesis fixes without manual work on your end</li> <li>People cannot confirm the source code that made the exe.  Git Patcher systems compile the code on the users machine, so the code they see in Github is ensured to be the code that they're running.</li> <li>Linux users cannot use exes</li> </ul> <p>Not Recommended</p> <p>Uploading exes directly leads to a fragile ecosystem, and is not recommended</p>"},{"location":"devs/Patcher-CLI/","title":"Patcher CLI","text":"<p>Most of the documentation so far has been focused on making Mutagen-based patchers that are easily addable via Synthesis UI, but any program can be a patcher in Synthesis as long as it conforms to a few standards.</p> <p>This section talks about the CLI that patchers respond to, not the CLI that the Synthesis engine responds to.</p>"},{"location":"devs/Patcher-CLI/#general-workflow","title":"General Workflow","text":"<ul> <li>Synthesis will pass you command line instructions</li> <li>A previous patch file path may be given, which should be built on top of</li> <li>A path will be given to export your results to</li> <li>Shut down</li> </ul>"},{"location":"devs/Patcher-CLI/#run-patcher-cli","title":"Run Patcher CLI","text":"<p>The Synthesis pipeline passes in command line arguments to request a patch to be made. </p> <ul> <li><code>-s</code>/<code>--SourcePath</code>: Optional path to the previous patch file to build onto</li> <li><code>-o</code>/<code>--OutputPath</code>: Path an output patch is expected to be written to</li> <li><code>-g</code>/<code>--GameRelease</code>: The game the patch is expected to be run on (SkyrimSE/SkyrimLE/Oblivion/etc)</li> <li><code>-d</code>/<code>--DataFolderPath</code>: The path to the data folder to look for mods.  This may or may not be the typical install folder</li> <li><code>-l</code>/<code>--LoadOrderFilePath</code>: The path to the load order file to use.  This may or may not be the typical plugins.txt</li> </ul>"},{"location":"devs/Patcher-CLI/#other-commands","title":"Other Commands","text":"<p>There may be other commands Synthesis sends.  Any of these are optional and do not need to be supported in order to be compatible.</p>"},{"location":"devs/Publishing/","title":"Publishing","text":"<p>Once you have a patcher that you want to share with the world, there are a few options:</p>"},{"location":"devs/Publishing/#upload-to-github","title":"Upload to Github","text":"<p>Uploading to Github is the preferred route for publishing a patcher.</p> <ul> <li>Automatically listed in the Patcher Browser registration systems.</li> <li>Still can be used with the Nexus</li> <li>Easy versioning via tags</li> <li>Easy exposure of \"experimental\" versions to willing users via branches</li> <li>Gives your end users ability to upgrade to newer Mutagen/Synthesis versions without bugging you</li> <li>Will hook in to systems to improve overall patching speed, that will be developed in the future</li> <li>Source code is viewable, and people can help improve it with PRs</li> </ul>"},{"location":"devs/Publishing/#some-resources","title":"Some Resources","text":"<p>If you're new to Git, don't worry.  This wiki page should go over the gritty details you specifically need to get up and running.</p> <p>If you want to learn more about Git in general, though, there are a lot of resources online.</p>"},{"location":"devs/Publishing/#how-to-upload","title":"How to Upload","text":"<ul> <li>Create a Github Account</li> <li>Find your preferred Git tool</li> <li>Create a Local Git Repository</li> <li>Commit your code</li> <li>Upload</li> </ul>"},{"location":"devs/Publishing/#create-a-github-account","title":"Create a GitHub Account","text":"<p>Sign up for a GitHub account if you haven't already.  It's free.</p>"},{"location":"devs/Publishing/#find-your-preferred-git-tool","title":"Find your preferred Git tool","text":"<p>For the purpose of this tutorial, GitKraken will be the git client of choice.  There are a lot of options to choose from.</p> <p></p>"},{"location":"devs/Publishing/#create-a-local-git-repository","title":"Create a Local Git Repository","text":"<p>Using the GUI, create a local repository on the Solution folder.</p> <p></p>"},{"location":"devs/Publishing/#commit-your-code","title":"Commit your code","text":"<p>Git is essentially a code saving tool, with the ability to easily see changes and teleport to any saved state in the past.  There are a lot of tutorials on the internet, so this wiki will not go over all the basics besides the absolute essentials.</p> <p>To save your code, you will want to make a commit</p> <p></p> <p>In the center, you will notice a <code>WIP</code> section, which means you have code that is not saved.</p> <p>By moving files from the <code>Unstaged Files</code> section on the right-hand side to the <code>Staged Files</code>, you are marking the files to include in the commit (save).</p> <p>After typing in a message, you can then commit and save your code.  Once you do more work, you will notice more <code>WIP</code> code that you can then make another save with another commit later on.</p>"},{"location":"devs/Publishing/#upload","title":"Upload","text":"<p>First, you will want to log into Github within GitKraken's preferences.</p> <p>After logging in, you can initialize and upload to Github within the GUI itself.</p> <p></p> <p>Your code is now on Github!  Synthesis will automatically pick it up, and show it within the Patcher Browser.</p>"},{"location":"devs/Publishing/#versioning","title":"Versioning","text":"<p>An important part of exposing your patcher to the world is properly versioning.  This helps users control and decide what version of code they want to use.</p>"},{"location":"devs/Publishing/#versioned-tags-to-mark-releases","title":"Versioned Tags to mark releases","text":"<p>You can stamp specific commits with a tag to mark it as a version users can choose from.  </p> <p>User's perspective:</p> <p></p> <p>To create a tag, simply right click the commit you want to mark</p> <p></p> <p>You can type anything as the tag name, but it is recommended to follow semantic versioning.</p>"},{"location":"devs/Publishing/#branches","title":"Branches","text":"<p>Branches help to separate stable code from experimental code.  By default, <code>master</code>/<code>main</code> branch is the published stable code.  One pattern you can choose is to keep the <code>main</code> branch as your stable code, while pushing new work to a side <code>dev</code> branch until it is deemed stable.</p> <p>Additionally, extremely experimental code can be put on different named branches.  When working with users on fixing/trying new stuff, you can tell them to use the code from a specific side branch.  If the experiment works out, you can merge the code into <code>main</code>, or delete the branch entirely.</p> <p>User's Perspective:</p> <p></p>"},{"location":"devs/Publishing/#patcher-browser-registration","title":"Patcher Browser Registration","text":"<p>The Synthesis UI features a patcher browser which allows users to easily search and add patchers right within the app.</p> <p>This listing is populated by a periodic scraper that compiles the big list of available patchers.  In order to show up in the patcher browser, you need to show up on that list.</p> <p>In order to be found/listed there are a few requirements:</p> <ul> <li>In a git repository uploaded to GitHub.com</li> <li>Solution is top level (#211)</li> <li>At least one patcher project which imports the <code>Mutagen.Bethesda.Synthesis</code> NuGet package</li> <li>(Optional) Patcher meta json file specifying description and other information.  These can be made easily by utilizing the Solution Patcher system made for devs</li> </ul> <p>The Local Solution patcher wizard will create an automatically compatible setup EXCEPT the first step of creating and uploading to GitHub.  This responsibility is on the patcher developer to create their Github presence.</p> <p>NOTE:  It is possible to have a single solution with several patcher projects underneath.  Whether you prefer a separate solution and repository per patcher, or one large repository with several patchers is up to personal preference.</p>"},{"location":"devs/Publishing/#troubleshooting-registration","title":"Troubleshooting Registration","text":""},{"location":"devs/Publishing/#github-dependency-graph","title":"Github Dependency Graph","text":"<p>The scraper tech functions by looking at the GitHub dependency graph systems.  The list can be found here</p> <p>There is also a list on your patcher side, where it shows what it is dependent on.  This will be in the same area, just in your own repo.</p> <p>If you don't find your patcher on this list, then the scraper will not see your patcher and so it will not show up.</p> <p>First, double check that you've actually imported <code>Mutagen.Bethesda.Synthesis</code> into your project, as that's what drives it.   Second, sometimes Github doesn't populate these lists as we'd desire.   Some have solved the issue by going to their patcher's dependencies list, and refreshing the page.   Otherwise sometimes you have to open up a ticket with Github and tell them to poke the system on their end.</p>"},{"location":"devs/Publishing/#error-during-scraping","title":"Error During Scraping","text":"<p>Sometimes there can be error during the scraping event.   The scraper system tries to list all the patchers it saw on the list, and whether they were excluded and why.  The readout can be found here</p> <p>If you see your patcher with an error, see if it makes sense and if you can adjust for what it's complaining about.</p>"},{"location":"devs/Publishing/#delisting-patcher","title":"Delisting patcher","text":"<p>If you want to delist your patcher, you can by including a <code>SynthesisMeta.json</code> meta file with instructions to do so.   This goes next to the .csproj for the patcher.</p> <p>Here's an example of one: <pre><code>{\n  \"Nickname\": \"My Awesome Patcher\",\n  \"Visibility\": \"Exclude\",\n  \"OneLineDescription\": \"A one liner description\",\n  \"LongDescription\": \"Some longer description\",\n  \"PreferredAutoVersioning\": \"Default\",\n  \"RequiredMods\": []\n}\n</code></pre></p> <p>Options are:</p> <ul> <li>Visible (default)</li> <li>IncludeButHide</li> <li>Exclude</li> </ul> <p>One alternative way to make and modify this meta file is to use the Solution Patcher suite.  This setup has settings panels you can use, one of which allows you to set the visibility of your patcher easily.</p> <p> Solution Patcher</p>"},{"location":"devs/Publishing/#build-executable","title":"Build Executable","text":"<p>You can also build an executable, and distribute the <code>exe</code> directly for users.  They would then add it as an External Program Patcher</p>"},{"location":"devs/Runnability-Checks/","title":"Required Mods and Runnability Checks","text":"<p>Often a patcher requires some mods or has some other requirements where it knows it will fail if certain things aren't present or correct.</p> <p>These can be written into a Runnability check, which Synthesis will run ahead of time before the user has even started a patching run.  If the check fails, then Synthesis will warn the user and block them from starting.   This is helpful, as if you instead put the check inside your RunPatch logic, then the user will find out way later perhaps after they've waited several minutes for patchers earlier in the pipeline to complete.  It's best to fail and warn as early as possible.</p>"},{"location":"devs/Runnability-Checks/#runnability-check","title":"Runnability Check","text":"<p>Adding a Runnability check is as easy as adding the RunPatch callback.</p> <pre><code>public static Task&lt;int&gt; Main(string[] args)\n{\n    return SynthesisPipeline.Instance\n        // Add the runnability check via the pipeline builder\n        .AddRunnabilityCheck(CheckRunnability)\n        // The normal other items\n        .AddPatch&lt;ISkyrimMod, ISkyrimModGetter&gt;(RunPatch)\n        .SetTypicalOpen(GameRelease.SkyrimSE, \"YourPatcher.esp\")\n        .Run(args);\n}\n\npublic static void CheckRunnability(IRunnabilityState state)\n{\n    // Check and throw exceptions as necessary\n}\n</code></pre> <p>Synthesis will identify this function exists and call it when it's interested if your patcher is runnable.</p>"},{"location":"devs/Runnability-Checks/#best-practices","title":"Best Practices","text":"<p>Runnability checks are meant for quick easily verifiable items like the presence of mods/files/etc.  Synthesis may run them often.  It's best to keep these checks as cheap as possible and not do any work within them.</p> <p>If an obscure requirement takes a lot of work to identify whether it would succeed or not, and might take several seconds to calculate, then that's best to keep that expensive logic within the RunPatch side.</p>"},{"location":"devs/Runnability-Checks/#required-mods","title":"Required Mods","text":"<p>Given that this is a common requirement of patchers to have a mod they require, there are special systems in place to help facilitate this.</p>"},{"location":"devs/Runnability-Checks/#via-meta-file","title":"Via Meta File","text":"<p>If you add your patcher as a Solution Patcher to Synthesis, then it will offer you a convenient place to add Required Mods in the UI.</p> <p></p> <p>This route is preferable, as it adds the required mods to a meta file that is committed alongside the code.  Scrapers and other tools are more easily able to identify required mods for a patcher when they're listed this way.</p>"},{"location":"devs/Runnability-Checks/#via-runnability-check-function","title":"Via Runnability Check Function","text":"<p>You can also add the required mods check to an existing runnability function with some provided convenience methods: <pre><code>public static void CheckRunnability(IRunnabilityState state)\n{\n    state.LoadOrder.AssertListsMod(\"RequiredMod.esp\");\n}\n</code></pre></p>"},{"location":"devs/Running-and-Debugging/","title":"Running and Debugging","text":""},{"location":"devs/Running-and-Debugging/#running-your-code","title":"Running Your Code","text":""},{"location":"devs/Running-and-Debugging/#directly","title":"Directly","text":"<p>While developing a patcher, you will want to be able to run your code, debug, and see results.  Running directly from the IDE will mean your patcher is running as a normal C# program, with all the developer features you expect.</p>"},{"location":"devs/Running-and-Debugging/#standalone-run-configuration","title":"Standalone Run Configuration","text":"<p>Normally the Synthesis UI specifies to your patcher where the output should end up.  When running standalone, your patcher needs this extra information that is usually provided.  </p> <p>The <code>SetTypicalOpen</code> call that comes with the typical template informs your patcher what the desired behavior is when run standalone.</p> <p> Standalone Run Configuration</p>"},{"location":"devs/Running-and-Debugging/#explicit-side-environment","title":"Explicit Side Environment","text":"<p>A typical run will look to your default Plugins.txt and Data folder, which may or may not contain content you want to test against.   One route for testing against a specific load order is to set up a secondary side <code>Data</code> folder and <code>Plugins.txt</code> load order file.</p> <p>To tell your patcher to latch onto that side environment, you can utilize the CLI Arguments to give it the details to use.  Here is an example set of arguments:</p> <pre><code>run-patcher --GameRelease SkyrimSE --DataFolderPath \"Path/To/Side/Data\"\n--LoadOrderFilePath \"Path/To/Side/Plugins.txt\" --OutputPath \"Some/Path/YourMod.esp\"\n</code></pre>"},{"location":"devs/Running-and-Debugging/#solution-patchers-via-synthesis-gui","title":"Solution Patchers via Synthesis GUI","text":"<p>Patcher solutions can be run from inside the Synthesis GUI, by adding them as a Synthesis patcher.  The recommended type is Solution patchers, but External Program can be used, too.</p> <p>Notes:</p> <ul> <li>Lets you run your in-development patcher alongside several other patchers to see their combined results</li> <li>Not really the best route for testing just your patcher alone; Use the Direct method mentioned above instead.</li> </ul>"},{"location":"devs/Running-and-Debugging/#run-through-mo2","title":"Run through MO2","text":"<p>Any of the above options can also be executed in the context of Mod Organizer 2's Virtual File System.  Adding Visual Studio as a program to be run, for example, lets you run your patcher against a MO2 managed load order while retaining the ability to debug and step through your code in the IDE.</p> <p>May Require Reopening</p> <p>Visual Studio or Synthesis GUI through MO2 is only good for one run or so before the VFS mapping seems to break down and the apps need to be reopened.  Some research needs to be done to figure out why this isn't more stable over multiple runs</p>"},{"location":"devs/Running-and-Debugging/#debugging-your-code","title":"Debugging Your Code","text":"<p>Debugging is an important part of coding, as it allows you to more quickly get to the bottom of the bugs and behavior of your patcher.</p>"},{"location":"devs/Running-and-Debugging/#console-logging","title":"Console Logging","text":"<p>You can write console lines, which will print to the console during development, and also to the Synthesis UI for end users.</p> <pre><code>Console.WriteLine(\"Hello World\");\n</code></pre> <p>Use for Useful Messages</p> <p>Console logs should also be informative to read for users.  Only add a console line if it helps get an overview of the program's progress without spamming excessively.</p>"},{"location":"devs/Running-and-Debugging/#debugger-and-breakpoints","title":"Debugger and Breakpoints","text":"<p>Often a bug will be harder to diagnose or understand.  Rather than logging every last small step your program does to the console, you can utilize your IDE's debugger to investigate your program</p>"},{"location":"devs/Supporting-Multiple-Games/","title":"Supporting Multiple Games","text":""},{"location":"devs/Supporting-Multiple-Games/#supporting-multiple-games_1","title":"Supporting Multiple Games","text":"<p>By adding a 2nd (or more) AddPatch commands to your SynthesisPipeline you can have your patcher support different game categories.  Note that the generics will be for a different Mod object, and so a 2nd RunPatch callback with the appropriate mod will be required as an entry point <pre><code>public static async Task&lt;int&gt; Main(string[] args)\n{\n    return await SynthesisPipeline.Instance\n        .AddPatch&lt;ISkyrimMod, ISkyrimModGetter&gt;(RunPatch)\n        .AddPatch&lt;IFallout4Mod, IFallout4ModGetter&gt;(RunPatch)\n        .SetTypicalOpen(GameRelease.SkyrimSE, \"YourPatcher.esp\")\n        .Run(args);\n}\n\npublic static void RunPatch(IPatcherState&lt;ISkyrimMod, ISkyrimModGetter&gt; state)\n{\n    //Your Skyrim code here!\n}\n\npublic static void RunPatch(IPatcherState&lt;IFallout4Mod, IFallout4ModGetter&gt; state)\n{\n    //Your Fallout4 code here!\n}\n</code></pre></p> <p>At this point, your patcher supports multiple game types, and can respond accordingly when it is run with either game.</p>"},{"location":"devs/Supporting-Multiple-Games/#code-reuse","title":"Code Reuse","text":"<p>The entry points as shown above make it easy to \"support\" multiple games, but it is still a challenge to properly develop your code in a way that it can be reused for both.  It requires more advanced knowledge of generics, Aspect Interfaces, Reflection, and other similar concepts.</p> <p>Making multi-game support easier to code without dipping into as many of those advanced concepts is a frontier topic of Mutagen, so feel free to stop by the discord and chat and brainstorm!</p>"},{"location":"devs/Synthesis-Collective/","title":"Synthesis Collective","text":"<p>This is a side organization related to Synthesis, which houses patchers written and maintained by the community.  </p> <p>Its main goal is to relieve patcher developers from maintenance work.  The community driven team can help maintain/approve small fixes to the collection, without needing to funnel every action through a single person.  Each patcher retains the original authors as explicit collaborators who have full read/write access.  Additionally, a small team also has access to all repos within the collective, which allows them to also make/approve fixes/tweaks to any given patcher.</p> <p>The organization may evolve over time, but these general ideals will remain steady.</p> <p> The Synthesis Collective</p>"},{"location":"devs/Synthesis-Collective/#ownership","title":"Ownership","text":"<p>Be aware that a patcher added to the Collective is then under full ownership of the Collective, which follows a Cathedral ideal.  An original author cannot forcefully request a patcher be removed from the Collective and transferred back to them, or deleted.  They of course are able to fork the patcher and deviate from there as they wish.</p> <p>The original author remains the main head of any given patcher as long as they wish.  The goal of the collective is to provide maintenance and bugfix support rather than take over and reimagine any given patcher.  Small features might be added by popular community demand if the original author is absent.</p> <p>An author may be blocked access to the patcher they added in the case of intentional sabotage (wiping commits, etc).</p>"},{"location":"devs/Synthesis-Collective/#is-the-collective-a-good-fit-for-you-and-your-patcher","title":"Is the Collective a good fit for you and your patcher?","text":"<ul> <li>Is maintenance/small fixes not of interest to you?</li> <li>Have you moved on to other projects?</li> <li>Is an iron grip on your code not too important to you?</li> <li>Do you care about Cathedral ideals, and want your patcher to outlive you and your modding days?</li> </ul> <p>Then the Collective might be a good option to consider.</p>"},{"location":"devs/Synthesis-Collective/#do-you-have-to-put-patchers-in-the-collective-to-contribute","title":"Do you have to put patchers in the Collective to contribute?","text":"<p>No!  You can contribute to the patchers within the Collective and improve them, while also having your own personal patchers under your own github name.   Moving any patchers to the Collective is a 100% separate and voluntary action.</p>"},{"location":"devs/Synthesis-Collective/#how-to-become-part-of-the-collective","title":"How to become part of the Collective","text":"<ul> <li>Request membership to the Collective.  Github does not have a way to initiate this yourself, unfortunately, so swing by the discord and ask in the Synthesis channels to be invited.</li> <li>Transfer your repository to the Collective.  (Main Github Repo Page -&gt; Settings -&gt; Options -&gt; Scroll down -&gt; Transfer Ownership to <code>Synthesis-Collective</code>)</li> <li>You will automatically be added as a collaborator (full read/write access) to the transferred repository</li> <li>You can fork your own copy if you wish, or just work directly on the main repo that now lives within the Collective.</li> <li>If you do not fork, all links to your previous repo's location will automatically redirect to the collective's copy.</li> </ul>"},{"location":"devs/Synthesis-Collective/#style-and-formatting","title":"Style and Formatting","text":"<p>Everyone codes differently, especially in an environment like this where everyone is from different coding backgrounds.  This is okay for new and exploratory code.</p> <p>However, patchers within the collective should gravitate towards C# Visual Studio formatting rules.  If you're adjusting code that already exists, it should not move -farther- away from C# styling.  As such, over time, most patchers within the collective should stabilize into VS formatted code and C# naming conventions.</p> <p>None of this is a strict rule, but just a general guideline that should be considered when making a PR to contribute to a Collective patcher.  PRs that aggressively deviate existing code away from typical C# formatting can be asked to reverse those changes before the PR will be accepted.</p> <p>More questions?  Swing by the Discord and chat!</p>"},{"location":"devs/User-Input/","title":"User Input","text":"<p>There are a few ways patchers can retrieve input from the user.</p>"},{"location":"devs/User-Input/#automatic-settings-ui-system","title":"Automatic Settings UI System","text":"<p>Typically users don't like interacting with raw configs.  The format looks like code, is heavily error prone, and does not have any helpful functionality to fill things out for the user or ensure the input is correct.</p> <p>Synthesis offers an alternative to raw configuration files to instead provide an out of the box UI for settings.  </p>"},{"location":"devs/User-Input/#define-some-settings","title":"Define Some Settings","text":"<p>As a developer, you provide a class with the fields you would like to expose: <pre><code>public class TestSettings\n{\n    public bool MyBool;\n    public string MyString = string.Empty;\n    public FormKey MyFormKey;\n    public IFormLinkGetter&lt;IArmorGetter&gt; MyArmor = FormLink&lt;IArmorGetter&gt;.Null;\n}\n</code></pre></p>"},{"location":"devs/User-Input/#use-the-settings","title":"Use the Settings","text":"<p>Use the settings class in your code: <pre><code>// Define a variable to hold the settings\nstatic Lazy&lt;TestSettings&gt; Settings = null!;\n\n// The typical synthesis bootstrap code\npublic static Task&lt;int&gt; Main(string[] args)\n{\n    return SynthesisPipeline.Instance\n        .AddPatch&lt;ISkyrimMod, ISkyrimModGetter&gt;(RunPatch)\n        // Fill the settings variable, and provide the file on disk that will store the settings\n        .SetAutogeneratedSettings(\n                    nickname: \"Settings\",\n                    path: \"settings.json\",\n                    out Settings)\n        .SetTypicalOpen(GameRelease.SkyrimSE, \"MyPatcher.esp\")\n        .Run(args);\n}\n\npublic static void RunPatch(IPatcherState&lt;ISkyrimMod, ISkyrimModGetter&gt; state)\n{\n    // Use the settings\n    if (Settings.Value.MyBool)\n    {\n        Console.WriteLine(\"MyBool was on!\");\n    }\n}\n</code></pre></p>"},{"location":"devs/User-Input/#get-a-ui-for-free","title":"Get a UI For Free","text":"<p>Synthesis will inspect your patcher via reflection, and will provide users a nice UI to interact with your settings</p> <p></p>"},{"location":"devs/User-Input/#more-documentation","title":"More Documentation","text":"<p>This feature is actually part of Mutagen, meaning it can be used for applications besides Synthesis.</p> <p>As such, the heavy documentation for it is located in the Mutagen repository</p> <p>It will go into detail on how to use the feature, what fields/structures are allowed, and what other extra functionality exists.</p>"},{"location":"devs/User-Input/#jsonxml-or-other-raw-config-file","title":"JSON/XML or Other Raw Config File","text":"<p>One option is to expect a json/xml/other file with the values you want to read in from your patcher.  Users can then modify this file to control how your patcher behaves.</p> <p>Synthesis provides an area for you to place/expect files that you can read in to get input.</p>"},{"location":"devs/User-Input/#user-data-folder","title":"User Data Folder","text":"<p>Just for reference, when users install your patcher they will find your default config files inside: <code>[Synthesis Exe Path]/Data/[Name of Patcher]/</code></p> <p>This is where the users will interact with your settings files.   Synthesis is in charge of moving any of your default config files to this location for you.  You do not need to worry about placing files here for the user.</p>"},{"location":"devs/User-Input/#using-config-files-in-your-patcher","title":"Using Config Files in your Patcher","text":"<p>To apply any settings the user has provided in the folder mentioned above, you'll want to load in your config files.</p> <pre><code>string settingsPath = Path.Combine(state.ExtraSettingsDataPath, \"ThePathYouGaveYourConfig.json\");\nif (!File.Exists(settingsPath)) throw new ArgumentException($\"Required settings missing! {settingsPath}\");\n// Use the file.  Perhaps pipe this to a Json/xml parser, etc\nvar configText = File.ReadAllText(settingsPath);\n</code></pre> <p>Note that you only need to provide the subpath relative to <code>Data/</code>, not the full path to your config file.</p> <p>Synthesis provides an even easier convenience API, as well: <pre><code>// Perhaps pipe this to a Json/xml parser, etc\nvar configText = File.ReadAllText(state.RetrieveConfigFile(\"ThePathYouGaveYourConfig.json\"));\n</code></pre> This will automatically check if the config exists, and throw with some informative messages if not.</p>"},{"location":"devs/User-Input/#default-settings","title":"Default Settings","text":"<p>Typically you want to provide your users with some default settings, you can place files within a <code>Data</code> subfolder next to your <code>.csproj</code> file.  Synthesis will look for files in this location, and copy them to the User Data Folder so that they have a baseline to work with.</p> <p><code>[Path To Solution Folder]/[Path To Project Folder]/Data/[... Any default files ...]</code></p> <p>The default files you define within your project will only be copied over to the User Data Folder if it is empty for your patcher.  For example, if content already exists within <code>[Exe Path]/Data/[Name of Patcher]/</code>, then no files will ever be copied into it.  It is assumed the user might have customized the files and would prefer not to lose their changes.  To have settings revert to default, just inform the user to delete the settings folder for your patcher, and it will be replaced with the defaults.</p>"},{"location":"devs/User-Input/#custom-ui","title":"Custom UI","text":"<p>The patcher itself can be a UI application that can run as both a background executable (when patching) and a UI app (when modifying settings).   This is a more advanced option for developers that need very custom settings that the above options cannot provide. </p> <p>A proof of concept template project can be found here</p>"}]}