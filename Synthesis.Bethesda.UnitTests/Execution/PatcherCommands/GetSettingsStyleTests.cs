using System.Diagnostics;
using Shouldly;
using Noggog;
using Noggog.Testing.Extensions;
using NSubstitute;
using Synthesis.Bethesda.Commands;
using Synthesis.Bethesda.DTO;
using Synthesis.Bethesda.Execution.PatcherCommands;
using Synthesis.Bethesda.Execution.Utility;
using Synthesis.Bethesda.UnitTests.AutoData;

namespace Synthesis.Bethesda.UnitTests.Execution.PatcherCommands;

public class GetSettingsStyleTests
{
    [Theory, SynthAutoData]
    public async Task PassesParametersToStartFactory(
        string path,
        bool directExe,
        FilePath? filePath,
        CancellationToken cancel,
        bool build,
        GetSettingsStyle sut)
    {
        await sut.Get(path, directExe, filePath, cancel, build);
        sut.GetRunProcessStartInfoProvider.Received(1).GetStart(path, directExe, new SettingsQuery(), build);
    }

    [Theory, SynthAutoData]
    public async Task PassesStartInfoToRun(
        string path,
        bool directExe,
        FilePath? filePath,
        CancellationToken cancel,
        bool build,
        ProcessStartInfo startInfo,
        GetSettingsStyle sut)
    {
        sut.GetRunProcessStartInfoProvider.GetStart<SettingsQuery>(default!, default, default!)
            .ReturnsForAnyArgs(startInfo);
        await sut.Get(path, directExe, filePath, cancel, build);
        await sut.ProcessRunner.Received(1).RunAndCapture(startInfo, cancel);
    }

    [Theory, SynthAutoData]
    public async Task OpenSettingsResultReturnsOpenResult(
        string path,
        bool directExe,
        FilePath? filePath,
        CancellationToken cancel,
        bool build,
        GetSettingsStyle sut)
    {
        sut.ProcessRunner.RunAndCapture(default!, default).ReturnsForAnyArgs(
            new ProcessRunReturn((int) Codes.OpensForSettings, default!, default!));
        var resp = await sut.Get(path, directExe, filePath, cancel, build);
        resp.Style.ShouldBe(SettingsStyle.Open);
        resp.Targets.ShouldBeEmpty();
    }

    [Theory, SynthAutoData]
    public async Task AutoGenSettingsPassesOutLinesToParser(
        string path,
        bool directExe,
        CancellationToken cancel,
        FilePath? filePath,
        bool build,
        List<string> outLines,
        GetSettingsStyle sut)
    {
        sut.ProcessRunner.RunAndCapture(default!, default).ReturnsForAnyArgs(
            new ProcessRunReturn((int) Codes.AutogeneratedSettingsClass, outLines, default!));
        await sut.Get(path, directExe, filePath, cancel, build);
        sut.LinesToConfigsParser.Received(1).Parse(outLines);
    }

    [Theory, SynthAutoData]
    public async Task AutoGenSettingsReturnsParseResults(
        string path,
        bool directExe,
        CancellationToken cancel,
        FilePath? filePath,
        bool build,
        ReflectionSettingsConfigs configs,
        GetSettingsStyle sut)
    {
        sut.ProcessRunner.RunAndCapture(default!, default).ReturnsForAnyArgs(
            new ProcessRunReturn((int) Codes.AutogeneratedSettingsClass, default!, default!));
        sut.LinesToConfigsParser.Parse(default!).ReturnsForAnyArgs(configs);
        var resp = await sut.Get(path, directExe, filePath, cancel, build);
        resp.Style.ShouldBe(SettingsStyle.SpecifiedClass);
        resp.Targets.ShouldEqual(configs.Configs);
    }

    [Theory, SynthAutoData]
    public async Task OtherResultsReturnNone(
        string path,
        bool directExe,
        CancellationToken cancel,
        FilePath? filePath,
        bool build,
        GetSettingsStyle sut)
    {
        sut.ProcessRunner.RunAndCapture(default!, default).ReturnsForAnyArgs(
            new ProcessRunReturn((int) Codes.Unsupported, default!, default!));
        var resp = await sut.Get(path, directExe, filePath, cancel, build);
        resp.Style.ShouldBe(SettingsStyle.None);
        resp.Targets.ShouldBeEmpty();
    }
}